// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var Block                   = require("bs-platform/lib/js/block.js");
var Curry                   = require("bs-platform/lib/js/curry.js");
var Caml_exceptions         = require("bs-platform/lib/js/caml_exceptions.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var $$Error = Caml_exceptions.create("Parser-Languid.Basics.Error");

var Basics = /* module */[/* Error */$$Error];

function _menhir_goto_commands(_menhir_env, __menhir_stack, __menhir_s, __v) {
  while(true) {
    var _v = __v;
    var _menhir_s = __menhir_s;
    var _menhir_stack = __menhir_stack;
    if (_menhir_s !== 0) {
      if (_menhir_env[/* _menhir_error */3]) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "parser.ml",
                39,
                8
              ]
            ];
      }
      var _tok = _menhir_env[/* _menhir_token */2];
      if (_tok >= 4) {
        return _v;
      } else {
        if (_menhir_env[/* _menhir_error */3]) {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "parser.ml",
                  53,
                  12
                ]
              ];
        }
        _menhir_env[/* _menhir_error */3] = /* true */1;
        return _menhir_errorcase(_menhir_env, _menhir_stack, _menhir_s);
      }
    } else {
      var _v_000 = _menhir_stack[2];
      var _v$1 = /* :: */[
        _v_000,
        _v
      ];
      __v = _v$1;
      __menhir_s = _menhir_stack[1];
      __menhir_stack = _menhir_stack[0];
      continue ;
      
    }
  };
}

function _menhir_discard(_menhir_env) {
  var lexer = _menhir_env[/* _menhir_lexer */0];
  var lexbuf = _menhir_env[/* _menhir_lexbuf */1];
  var _tok = Curry._1(lexer, lexbuf);
  return /* record */[
          /* _menhir_lexer */lexer,
          /* _menhir_lexbuf */lexbuf,
          /* _menhir_token */_tok,
          /* _menhir_error : false */0
        ];
}

function _menhir_goto_command(_menhir_env, _menhir_stack, _menhir_s, _v) {
  var _menhir_stack$1 = /* tuple */[
    _menhir_stack,
    _menhir_s,
    _v
  ];
  if (_menhir_env[/* _menhir_error */3]) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "parser.ml",
            69,
            4
          ]
        ];
  }
  var _tok = _menhir_env[/* _menhir_token */2];
  switch (_tok) {
    case 0 : 
        return _menhir_run1(_menhir_env, _menhir_stack$1, /* MenhirState8 */0);
    case 1 : 
        return _menhir_run2(_menhir_env, _menhir_stack$1, /* MenhirState8 */0);
    case 2 : 
        return _menhir_run3(_menhir_env, _menhir_stack$1, /* MenhirState8 */0);
    case 3 : 
        return _menhir_run4(_menhir_env, _menhir_stack$1, /* MenhirState8 */0);
    case 4 : 
        var _v$1 = /* :: */[
          _v,
          /* [] */0
        ];
        return _menhir_goto_commands(_menhir_env, _menhir_stack, _menhir_s, _v$1);
    
  }
}

function _menhir_run4(_menhir_env, _menhir_stack, _menhir_s) {
  var _menhir_env$1 = _menhir_discard(_menhir_env);
  return _menhir_goto_command(_menhir_env$1, _menhir_stack, _menhir_s, /* Now */Block.__(0, [/* Listen */1]));
}

function _menhir_errorcase(_, __menhir_stack, __menhir_s) {
  while(true) {
    var _menhir_s = __menhir_s;
    var _menhir_stack = __menhir_stack;
    if (_menhir_s !== 0) {
      throw $$Error;
    } else {
      __menhir_s = _menhir_stack[1];
      __menhir_stack = _menhir_stack[0];
      continue ;
      
    }
  };
}

function _menhir_run2(_menhir_env, _menhir_stack, _menhir_s) {
  var _menhir_env$1 = _menhir_discard(_menhir_env);
  return _menhir_goto_command(_menhir_env$1, _menhir_stack, _menhir_s, /* Turn */Block.__(1, [/* Shoot */1]));
}

function _menhir_run1(_menhir_env, _menhir_stack, _menhir_s) {
  var _menhir_env$1 = _menhir_discard(_menhir_env);
  return _menhir_goto_command(_menhir_env$1, _menhir_stack, _menhir_s, /* Now */Block.__(0, [/* Walk */0]));
}

function _menhir_run3(_menhir_env, _menhir_stack, _menhir_s) {
  var _menhir_env$1 = _menhir_discard(_menhir_env);
  return _menhir_goto_command(_menhir_env$1, _menhir_stack, _menhir_s, /* Turn */Block.__(1, [/* Move */0]));
}

function prog(lexer, lexbuf) {
  var _menhir_env = /* record */[
    /* _menhir_lexer */lexer,
    /* _menhir_lexbuf */lexbuf,
    /* _menhir_token : () */0,
    /* _menhir_error : false */0
  ];
  var _menhir_stack_001 = _menhir_env[/* _menhir_lexbuf */1][/* lex_curr_p */11];
  var _menhir_stack = /* tuple */[
    /* () */0,
    _menhir_stack_001
  ];
  var _menhir_env$1 = _menhir_discard(_menhir_env);
  var _tok = _menhir_env$1[/* _menhir_token */2];
  switch (_tok) {
    case 0 : 
        return _menhir_run1(_menhir_env$1, _menhir_stack, /* MenhirState0 */1);
    case 1 : 
        return _menhir_run2(_menhir_env$1, _menhir_stack, /* MenhirState0 */1);
    case 2 : 
        return _menhir_run3(_menhir_env$1, _menhir_stack, /* MenhirState0 */1);
    case 3 : 
        return _menhir_run4(_menhir_env$1, _menhir_stack, /* MenhirState0 */1);
    case 4 : 
        if (_menhir_env$1[/* _menhir_error */3]) {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "parser.ml",
                  163,
                  8
                ]
              ];
        }
        _menhir_env$1[/* _menhir_error */3] = /* true */1;
        return _menhir_errorcase(_menhir_env$1, _menhir_stack, /* MenhirState0 */1);
    
  }
}

var _eRR = $$Error;

exports.Basics                = Basics;
exports.$$Error               = $$Error;
exports._eRR                  = _eRR;
exports._menhir_goto_commands = _menhir_goto_commands;
exports._menhir_goto_command  = _menhir_goto_command;
exports._menhir_errorcase     = _menhir_errorcase;
exports._menhir_run1          = _menhir_run1;
exports._menhir_run2          = _menhir_run2;
exports._menhir_run3          = _menhir_run3;
exports._menhir_run4          = _menhir_run4;
exports._menhir_discard       = _menhir_discard;
exports.prog                  = prog;
/* No side effect */
