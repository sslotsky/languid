// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var Block             = require("bs-platform/lib/js/block.js");
var Curry             = require("bs-platform/lib/js/curry.js");
var Format            = require("bs-platform/lib/js/format.js");
var Js_exn            = require("bs-platform/lib/js/js_exn.js");
var Lexing            = require("bs-platform/lib/js/lexing.js");
var Lexer$Slangwidge  = require("./lexer.bs.js");
var Parser$Slangwidge = require("./parser.bs.js");

function info(lexbuf) {
  var pos = lexbuf[/* lex_curr_p */11];
  var line = pos[/* pos_lnum */1];
  var column = (pos[/* pos_cnum */3] - pos[/* pos_bol */2] | 0) + 1 | 0;
  var last_token = Lexing.lexeme(lexbuf);
  return Curry._3(Format.sprintf(/* Format */[
                  /* String_literal */Block.__(11, [
                      "Parse failed at line ",
                      /* Int */Block.__(4, [
                          /* Int_d */0,
                          /* No_padding */0,
                          /* No_precision */0,
                          /* String_literal */Block.__(11, [
                              ", column ",
                              /* Int */Block.__(4, [
                                  /* Int_d */0,
                                  /* No_padding */0,
                                  /* No_precision */0,
                                  /* String_literal */Block.__(11, [
                                      ":\n Last token: ",
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* End_of_format */0
                                        ])
                                    ])
                                ])
                            ])
                        ])
                    ]),
                  "Parse failed at line %d, column %d:\n Last token: %s"
                ]), line, column, last_token);
}

function read(s) {
  var lexbuf = Lexing.from_string(s);
  try {
    return /* Some */Block.__(0, [Parser$Slangwidge.prog(Lexer$Slangwidge.read, lexbuf)]);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Lexer$Slangwidge.$$SyntaxError) {
      return /* Err */Block.__(1, [Curry._2(Format.sprintf(/* Format */[
                          /* String_literal */Block.__(11, [
                              "Failed with ",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* String_literal */Block.__(11, [
                                      " at ",
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* End_of_format */0
                                        ])
                                    ])
                                ])
                            ]),
                          "Failed with %s at %s"
                        ]), exn[1], info(lexbuf))]);
    } else if (exn === Parser$Slangwidge.$$Error) {
      return /* Err */Block.__(1, [info(lexbuf)]);
    } else {
      throw exn;
    }
  }
}

exports.info = info;
exports.read = read;
/* Format Not a pure module */
